#!/usr/bin/env bash
#
# gh2fizzy - Migrate GitHub Issues to Fizzy Cards
#
# Usage: gh2fizzy --board BOARD_ID [options]
#
# See gh2fizzy --help for full documentation.
#

set -euo pipefail

# Script version
VERSION="1.0.0"

# Default values
REPO=""
STATE="open"
STATE_SET=false  # Track if user explicitly set --state
LABELS=()
ASSIGNEE=""
MILESTONE=""
LIMIT=100
ISSUES=()

FIZZY_ACCOUNT_ID="${FIZZY_ACCOUNT:-}"
BOARD_ID=""
COLUMN_ID=""

DRY_RUN=false
VERBOSE=false
QUIET=false
CLOSE_ISSUES=false
ADD_MIGRATED_LABEL=false
PRESERVE_NUMBERS=false
ISSUES_FILE=""  # Cache file for GitHub issues JSON
DUMP_BOARD_ID=""  # Board ID for placeholder cards (auto-created if needed)

# Counters for summary
TOTAL_ISSUES=0
SUCCESS_COUNT=0
FAIL_COUNT=0

# Color output helpers (disabled if not a terminal)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

log_info() {
    [[ "$QUIET" == "true" ]] && return
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_success() {
    [[ "$QUIET" == "true" ]] && return
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_verbose() {
    [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $*" >&2
}

die() {
    log_error "$1"
    exit "${2:-1}"
}

show_help() {
    cat << 'EOF'
gh2fizzy - Migrate GitHub Issues to Fizzy Cards

USAGE:
    gh2fizzy --board BOARD_ID [OPTIONS]

REQUIRED:
    --board BOARD_ID        Fizzy board ID to create cards in

GITHUB FILTERS:
    -R, --repo OWNER/REPO   GitHub repository (default: current repo)
    --state STATE           Issue state: open, closed, all (default: open)
    -l, --label LABEL       Filter by label (can be repeated)
    --assignee USERNAME     Filter by assignee
    --milestone TITLE       Filter by milestone
    --limit N               Maximum issues to migrate (default: 100)
    -i, --issue NUMBER      Specific issue number (can be repeated)

FIZZY OPTIONS:
    --account ACCOUNT_ID    Fizzy account ID (default: $FIZZY_ACCOUNT)
    --column COLUMN_ID      Place cards in specific column (default: triage)

BEHAVIOR:
    --dry-run               Preview without making changes
    -v, --verbose           Show detailed output
    -q, --quiet             Suppress non-error output
    --close-issues          Close GitHub issues after migration
    --add-migrated-label    Add "migrated-to-fizzy" label to issues
    --preserve-numbers      Create cards in issue number order and verify
                            Fizzy assigns matching card numbers (aborts on mismatch)
    --issues-file FILE      Read/write GitHub issues JSON from FILE (skips API call
                            if file exists; saves response if fetched)

OTHER:
    -h, --help              Show this help message
    --version               Show version

EXAMPLES:
    # Migrate all open issues to a board
    gh2fizzy --board 12345

    # Migrate specific issues
    gh2fizzy --board 12345 -i 42 -i 43

    # Migrate from specific repo with filters
    gh2fizzy -R owner/repo -l bug --state open --board 12345

    # Preview what would be migrated
    gh2fizzy --board 12345 --dry-run

    # Migrate and mark as migrated in GitHub
    gh2fizzy --board 12345 --close-issues --add-migrated-label
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                echo "gh2fizzy version $VERSION"
                exit 0
                ;;
            -R|--repo)
                REPO="$2"
                shift 2
                ;;
            --state)
                STATE="$2"
                STATE_SET=true
                shift 2
                ;;
            -l|--label)
                LABELS+=("$2")
                shift 2
                ;;
            --assignee)
                ASSIGNEE="$2"
                shift 2
                ;;
            --milestone)
                MILESTONE="$2"
                shift 2
                ;;
            --limit)
                LIMIT="$2"
                shift 2
                ;;
            -i|--issue)
                ISSUES+=("$2")
                shift 2
                ;;
            --account)
                FIZZY_ACCOUNT_ID="$2"
                shift 2
                ;;
            --board)
                BOARD_ID="$2"
                shift 2
                ;;
            --column)
                COLUMN_ID="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            --close-issues)
                CLOSE_ISSUES=true
                shift
                ;;
            --add-migrated-label)
                ADD_MIGRATED_LABEL=true
                shift
                ;;
            --preserve-numbers)
                PRESERVE_NUMBERS=true
                shift
                ;;
            --issues-file)
                ISSUES_FILE="$2"
                shift 2
                ;;
            *)
                die "Unknown argument: $1\nRun 'gh2fizzy --help' for usage." 2
                ;;
        esac
    done
}

validate_args() {
    if [[ -z "$BOARD_ID" ]]; then
        die "Missing required argument: --board BOARD_ID\nRun 'gh2fizzy --help' for usage." 2
    fi

    # Default to 'all' state when preserve-numbers is enabled (unless explicitly set)
    if [[ "$PRESERVE_NUMBERS" == "true" && "$STATE_SET" == "false" ]]; then
        STATE="all"
        log_verbose "Defaulting --state to 'all' for preserve-numbers mode"
    fi

    # Validate state
    if [[ ! "$STATE" =~ ^(open|closed|all)$ ]]; then
        die "Invalid --state value: $STATE. Must be: open, closed, or all" 2
    fi

    # Validate limit is a number
    if ! [[ "$LIMIT" =~ ^[0-9]+$ ]]; then
        die "Invalid --limit value: $LIMIT. Must be a positive integer" 2
    fi

    log_verbose "Arguments validated"
}

check_dependencies() {
    log_verbose "Checking dependencies..."

    local missing=()

    if ! command -v gh &>/dev/null; then
        missing+=("gh (GitHub CLI)")
    fi

    if ! command -v fizzy &>/dev/null; then
        missing+=("fizzy (Fizzy CLI)")
    fi

    if ! command -v jq &>/dev/null; then
        missing+=("jq (JSON processor)")
    fi

    # Check for markdown converter (optional but recommended)
    if ! command -v cmark &>/dev/null && ! command -v pandoc &>/dev/null; then
        log_warn "No markdown converter found (cmark or pandoc). Markdown will not be converted to HTML."
        MARKDOWN_CONVERTER=""
    elif command -v cmark &>/dev/null; then
        MARKDOWN_CONVERTER="cmark"
    else
        MARKDOWN_CONVERTER="pandoc"
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required tools:"
        for tool in "${missing[@]}"; do
            echo "  - $tool"
        done
        exit 3
    fi

    log_verbose "All dependencies found"
}

check_auth() {
    log_verbose "Checking authentication..."

    # Check GitHub auth
    if ! gh auth status &>/dev/null; then
        die "GitHub CLI not authenticated. Run: gh auth login" 4
    fi

    # Check Fizzy auth
    if ! fizzy identity show &>/dev/null; then
        die "Fizzy CLI not authenticated. Run: fizzy auth login YOUR_TOKEN" 4
    fi

    log_verbose "Authentication verified"
}

# Convert markdown to HTML if converter is available
markdown_to_html() {
    local markdown="$1"

    if [[ -z "$MARKDOWN_CONVERTER" ]]; then
        # No converter, return as-is
        echo "$markdown"
        return
    fi

    if [[ "$MARKDOWN_CONVERTER" == "cmark" ]]; then
        echo "$markdown" | cmark --unsafe 2>/dev/null || echo "$markdown"
    else
        echo "$markdown" | pandoc -f gfm -t html 2>/dev/null || echo "$markdown"
    fi
}

build_gh_command() {
    local cmd="gh issue list"

    # Add repo if specified
    if [[ -n "$REPO" ]]; then
        cmd+=" --repo $REPO"
    fi

    # Add state filter
    cmd+=" --state $STATE"

    # Add label filters
    if [[ ${#LABELS[@]} -gt 0 ]]; then
        for label in "${LABELS[@]}"; do
            cmd+=" --label \"$label\""
        done
    fi

    # Add assignee
    if [[ -n "$ASSIGNEE" ]]; then
        cmd+=" --assignee $ASSIGNEE"
    fi

    # Add milestone
    if [[ -n "$MILESTONE" ]]; then
        cmd+=" --milestone \"$MILESTONE\""
    fi

    # Add limit
    cmd+=" --limit $LIMIT"

    # JSON output with all needed fields
    cmd+=" --json number,title,body,comments,author,createdAt,labels,state"

    echo "$cmd"
}

fetch_issues() {
    log_info "Fetching issues from GitHub..."

    local issues_json

    # If specific issues requested, fetch them individually
    if [[ ${#ISSUES[@]} -gt 0 ]]; then
        log_verbose "Fetching ${#ISSUES[@]} specific issue(s)..."
        issues_json="["
        local first=true
        for issue_num in "${ISSUES[@]}"; do
            local repo_flag=""
            [[ -n "$REPO" ]] && repo_flag="--repo $REPO"

            local issue_data
            issue_data=$(gh issue view "$issue_num" $repo_flag --json number,title,body,comments,author,createdAt,labels,state 2>/dev/null) || true

            if [[ -n "$issue_data" ]]; then
                [[ "$first" == "false" ]] && issues_json+=","
                issues_json+="$issue_data"
                first=false
            else
                log_warn "Issue #$issue_num not found, skipping"
            fi
        done
        issues_json+="]"
    else
        # Fetch based on filters
        local cmd
        cmd=$(build_gh_command)
        log_verbose "Running: $cmd"

        issues_json=$(eval "$cmd" 2>/dev/null) || die "Failed to fetch issues from GitHub"
    fi

    # Return the JSON
    echo "$issues_json"
}

create_fizzy_comment() {
    local card_number="$1"
    local author="$2"
    local body="$3"
    local created_at="$4"
    local fizzy_opts="$5"

    # Format the comment body with author attribution
    local formatted_body="*Migrated from GitHub - originally by @${author}*\n\n${body}"

    # Convert markdown to HTML
    local comment_file html_body
    comment_file=$(mktemp)
    html_body=$(markdown_to_html "$(echo -e "$formatted_body")")
    echo "$html_body" > "$comment_file"

    # Build the fizzy comment create command
    local cmd="fizzy comment create --card \"$card_number\" --body_file \"$comment_file\" $fizzy_opts"

    # Add created-at timestamp if available
    if [[ -n "$created_at" && "$created_at" != "null" ]]; then
        cmd+=" --created-at \"$created_at\""
    fi

    eval "$cmd" >/dev/null 2>&1
    local result=$?

    rm -f "$comment_file"
    return $result
}

create_fizzy_card() {
    local title="$1"
    local body="$2"
    local labels_json="$3"
    local comments_json="$4"
    local issue_number="$5"
    local created_at="$6"
    local expected_number="${7:-}"  # Optional: if set, verify card number matches
    local issue_state="${8:-open}"  # GitHub issue state: open or closed

    log_verbose "Creating card for issue #$issue_number: $title"

    # Build fizzy options
    local fizzy_opts=""
    [[ -n "$FIZZY_ACCOUNT_ID" ]] && fizzy_opts+=" --account $FIZZY_ACCOUNT_ID"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would create card: $title"
        log_verbose "[DRY-RUN] Description length: ${#body} chars"

        # Show labels that would be applied
        local label_count
        label_count=$(echo "$labels_json" | jq 'length')
        if [[ "$label_count" -gt 0 ]]; then
            local label_names
            label_names=$(echo "$labels_json" | jq -r '.[].name' | tr '\n' ', ' | sed 's/,$//')
            log_verbose "[DRY-RUN] Would apply tags: $label_names"
        fi

        # Show comment count
        local comment_count
        comment_count=$(echo "$comments_json" | jq 'length')
        if [[ "$comment_count" -gt 0 ]]; then
            log_verbose "[DRY-RUN] Would add $comment_count individual comment(s)"
        fi

        return 0
    fi

    # Convert markdown to HTML and create temp file for description
    local desc_file html_body
    desc_file=$(mktemp)
    html_body=$(markdown_to_html "$body")
    echo "$html_body" > "$desc_file"

    # Build the fizzy card create command
    local cmd="fizzy card create $fizzy_opts --board \"$BOARD_ID\" --title \"$title\" --description_file \"$desc_file\""

    # Add created-at timestamp if available
    if [[ -n "$created_at" && "$created_at" != "null" ]]; then
        cmd+=" --created-at \"$created_at\""
    fi

    # Create the card
    local response
    response=$(eval "$cmd" 2>&1) || true

    rm -f "$desc_file"

    # Parse response
    local success card_number
    success=$(echo "$response" | jq -r '.success // false' 2>/dev/null) || success="false"

    if [[ "$success" != "true" ]]; then
        local error_msg
        error_msg=$(echo "$response" | jq -r '.error.message // "Unknown error"' 2>/dev/null) || error_msg="$response"
        log_error "Failed to create card for issue #$issue_number: $error_msg"
        return 1
    fi

    # Try to get card number from response, or fetch most recent card
    card_number=$(echo "$response" | jq -r '.data.number // empty' 2>/dev/null)

    if [[ -z "$card_number" || "$card_number" == "null" ]]; then
        # fizzy card create doesn't return card data, fetch most recent card by title match
        log_verbose "Fetching card number for newly created card..."
        local cards_response
        cards_response=$(fizzy card list --board "$BOARD_ID" --all $fizzy_opts 2>/dev/null) || true
        card_number=$(echo "$cards_response" | jq -r --arg title "$title" '.data[] | select(.title == $title) | .number' 2>/dev/null | head -1)
    fi

    if [[ -z "$card_number" || "$card_number" == "null" ]]; then
        if [[ -n "$expected_number" ]]; then
            log_error "Cannot verify card number for issue #$issue_number - card number unavailable"
            return 2  # Special exit code for number verification failure
        fi
        log_success "Created card for issue #$issue_number (card number unavailable)"
        log_warn "Unable to retrieve card number - skipping tags and comments"
        return 0
    fi

    # Verify card number matches expected (if preserve-numbers mode)
    if [[ -n "$expected_number" && "$card_number" != "$expected_number" ]]; then
        log_error "Card number mismatch! Expected #$expected_number but got #$card_number"
        return 2  # Special exit code for number verification failure
    fi

    log_success "Created card #$card_number for issue #$issue_number"

    # Move to column if specified
    if [[ -n "$COLUMN_ID" ]]; then
        log_verbose "Moving card #$card_number to column $COLUMN_ID"
        fizzy card column "$card_number" --column "$COLUMN_ID" $fizzy_opts >/dev/null 2>&1 || \
            log_warn "Failed to move card to column"
    fi

    # Apply tags from labels
    local label_count
    label_count=$(echo "$labels_json" | jq 'length')
    if [[ "$label_count" -gt 0 ]]; then
        log_verbose "Applying $label_count tag(s) from labels..."
        local j=0
        while [[ $j -lt $label_count ]]; do
            local label_name
            label_name=$(echo "$labels_json" | jq -r ".[$j].name")
            fizzy card tag "$card_number" --tag "$label_name" $fizzy_opts >/dev/null 2>&1 || \
                log_warn "Failed to apply tag: $label_name"
            j=$((j + 1))
        done
    fi

    # Add migrated comments as individual comments
    local comment_count
    comment_count=$(echo "$comments_json" | jq 'length')
    if [[ "$comment_count" -gt 0 ]]; then
        log_verbose "Adding $comment_count comment(s) to card #$card_number"
        local k=0
        local comment_success=0
        local comment_fail=0
        while [[ $k -lt $comment_count ]]; do
            local author body created_at
            author=$(echo "$comments_json" | jq -r ".[$k].author.login // \"unknown\"")
            body=$(echo "$comments_json" | jq -r ".[$k].body // \"\"")
            created_at=$(echo "$comments_json" | jq -r ".[$k].createdAt // \"\"")

            if create_fizzy_comment "$card_number" "$author" "$body" "$created_at" "$fizzy_opts"; then
                comment_success=$((comment_success + 1))
            else
                comment_fail=$((comment_fail + 1))
            fi
            k=$((k + 1))
        done
        if [[ $comment_fail -gt 0 ]]; then
            log_warn "Failed to add $comment_fail of $comment_count comment(s)"
        fi
    fi

    # Close the card if the GitHub issue was closed
    if [[ "$issue_state" == "closed" || "$issue_state" == "CLOSED" ]]; then
        log_verbose "Closing card #$card_number (GitHub issue was closed)"
        fizzy card close "$card_number" $fizzy_opts >/dev/null 2>&1 || \
            log_warn "Failed to close card #$card_number"
    fi
}

# Find or create the "Dump" board for placeholder cards
get_or_create_dump_board() {
    local fizzy_opts=""
    [[ -n "$FIZZY_ACCOUNT_ID" ]] && fizzy_opts+=" --account $FIZZY_ACCOUNT_ID"

    # Look for existing Dump board
    local boards_response
    boards_response=$(fizzy board list $fizzy_opts 2>/dev/null) || true

    DUMP_BOARD_ID=$(echo "$boards_response" | jq -r '.data[] | select(.name == "Dump") | .id' 2>/dev/null | head -1)

    if [[ -n "$DUMP_BOARD_ID" && "$DUMP_BOARD_ID" != "null" ]]; then
        log_verbose "Found existing Dump board: $DUMP_BOARD_ID"
        return 0
    fi

    # Create the Dump board
    log_info "Creating Dump board for placeholder cards..."
    local create_response
    create_response=$(fizzy board create --name "Dump" $fizzy_opts 2>&1) || true

    DUMP_BOARD_ID=$(echo "$create_response" | jq -r '.data.id // empty' 2>/dev/null)

    if [[ -z "$DUMP_BOARD_ID" || "$DUMP_BOARD_ID" == "null" ]]; then
        log_error "Failed to create Dump board"
        return 1
    fi

    log_info "Created Dump board: $DUMP_BOARD_ID"
}

# Create a placeholder card in the Dump board to consume a card number
create_placeholder_card() {
    local target_number="$1"
    local fizzy_opts=""
    [[ -n "$FIZZY_ACCOUNT_ID" ]] && fizzy_opts+=" --account $FIZZY_ACCOUNT_ID"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_verbose "[DRY-RUN] Would create placeholder card #$target_number in Dump board"
        return 0
    fi

    local response
    response=$(fizzy card create \
        $fizzy_opts \
        --board "$DUMP_BOARD_ID" \
        --title "Placeholder #$target_number (PR or deleted issue)" 2>&1) || true

    local success
    success=$(echo "$response" | jq -r '.success // false' 2>/dev/null) || success="false"

    if [[ "$success" != "true" ]]; then
        log_error "Failed to create placeholder card"
        return 1
    fi

    # Close the placeholder card immediately
    fizzy card close "$target_number" $fizzy_opts >/dev/null 2>&1 || \
        log_warn "Failed to close placeholder card #$target_number"

    log_verbose "Created and closed placeholder card #$target_number in Dump board"
}

# Fill gaps in card numbers by creating placeholder cards
# Returns the number of placeholders created, or 1 on error
fill_number_gaps() {
    local current_max="$1"  # Current highest card number in Fizzy
    local target_number="$2"  # The issue number we want to create next

    local gaps_to_fill=$((target_number - current_max - 1))

    if [[ $gaps_to_fill -le 0 ]]; then
        return 0
    fi

    log_info "Filling $gaps_to_fill gap(s) before issue #$target_number..."

    # Ensure Dump board exists
    if [[ -z "$DUMP_BOARD_ID" ]]; then
        get_or_create_dump_board || return 1
    fi

    local filled=0
    for ((n = current_max + 1; n < target_number; n++)); do
        if ! create_placeholder_card "$n"; then
            log_error "Failed to fill gap at #$n"
            return 1
        fi
        filled=$((filled + 1))
    done

    echo "$filled"
}

post_migration_github() {
    local issue_number="$1"
    local repo_flag=""
    [[ -n "$REPO" ]] && repo_flag="--repo $REPO"

    if [[ "$DRY_RUN" == "true" ]]; then
        [[ "$CLOSE_ISSUES" == "true" ]] && log_info "[DRY-RUN] Would close issue #$issue_number"
        [[ "$ADD_MIGRATED_LABEL" == "true" ]] && log_info "[DRY-RUN] Would add 'migrated-to-fizzy' label to #$issue_number"
        return 0
    fi

    if [[ "$ADD_MIGRATED_LABEL" == "true" ]]; then
        log_verbose "Adding 'migrated-to-fizzy' label to issue #$issue_number"
        gh issue edit "$issue_number" $repo_flag --add-label "migrated-to-fizzy" 2>/dev/null || \
            log_warn "Failed to add label to issue #$issue_number"
    fi

    if [[ "$CLOSE_ISSUES" == "true" ]]; then
        log_verbose "Closing issue #$issue_number"
        gh issue close "$issue_number" $repo_flag 2>/dev/null || \
            log_warn "Failed to close issue #$issue_number"
    fi
}

print_summary() {
    echo ""
    echo "============================================"
    echo "Migration Summary"
    echo "============================================"
    echo "Total issues processed: $TOTAL_ISSUES"
    echo "Successfully migrated:  $SUCCESS_COUNT"
    echo "Failed:                 $FAIL_COUNT"
    echo "============================================"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo ""
        echo "This was a DRY RUN - no changes were made."
    fi
}

main() {
    parse_args "$@"
    validate_args
    check_dependencies
    check_auth

    log_info "Starting GitHub to Fizzy migration"
    [[ "$DRY_RUN" == "true" ]] && log_warn "DRY RUN MODE - no changes will be made"

    # Store original limit for later use in preserve-numbers mode
    local original_limit="$LIMIT"

    # When preserve-numbers is enabled, fetch all issues first, then apply limit after filtering
    if [[ "$PRESERVE_NUMBERS" == "true" ]]; then
        LIMIT=10000  # Fetch all issues
    fi

    # Fetch issues (from cache file or GitHub API)
    local issues_json
    local fetched_from_api=false

    if [[ -n "$ISSUES_FILE" && -f "$ISSUES_FILE" ]]; then
        log_info "Reading issues from cache file: $ISSUES_FILE"
        issues_json=$(cat "$ISSUES_FILE")
    else
        issues_json=$(fetch_issues)
        fetched_from_api=true

        # Save to cache file if specified
        if [[ -n "$ISSUES_FILE" ]]; then
            echo "$issues_json" > "$ISSUES_FILE"
            log_info "Saved issues to cache file: $ISSUES_FILE"
        elif [[ "$PRESERVE_NUMBERS" == "true" ]]; then
            # Auto-create cache file for preserve-numbers mode
            local cache_file="/tmp/gh2fizzy-issues-$(date +%Y%m%d-%H%M%S).json"
            echo "$issues_json" > "$cache_file"
            log_info "Saved issues to cache file: $cache_file"
            log_info "Re-run with --issues-file $cache_file to skip GitHub API call"
        fi
    fi

    # Restore original limit
    LIMIT="$original_limit"

    TOTAL_ISSUES=$(echo "$issues_json" | jq 'length')

    if [[ "$TOTAL_ISSUES" == "0" ]]; then
        log_warn "No issues found matching the criteria"
        exit 0
    fi

    log_info "Found $TOTAL_ISSUES issue(s) from GitHub"

    # Track current max card number for preserve-numbers mode (account-wide)
    local current_max_card=0

    # Sort and filter issues if preserve-numbers mode is enabled
    if [[ "$PRESERVE_NUMBERS" == "true" ]]; then
        log_info "Sorting issues by number for preserve-numbers mode..."
        issues_json=$(echo "$issues_json" | jq 'sort_by(.number)')

        # Fetch existing card numbers from Fizzy to skip already-migrated issues
        log_info "Fetching existing cards from Fizzy..."
        local fizzy_opts=""
        [[ -n "$FIZZY_ACCOUNT_ID" ]] && fizzy_opts+=" --account $FIZZY_ACCOUNT_ID"

        # Get cards from target board for filtering already-migrated issues
        local existing_cards
        existing_cards=$(fizzy card list --board "$BOARD_ID" --all $fizzy_opts 2>/dev/null) || true
        local existing_numbers
        existing_numbers=$(echo "$existing_cards" | jq -r '.data[].number // empty' 2>/dev/null | sort -n | tr '\n' ' ')

        # Find max card number across ALL boards (card numbers are account-wide)
        log_info "Finding highest card number in account..."
        local all_boards
        all_boards=$(fizzy board list $fizzy_opts 2>/dev/null) || true
        local board_ids
        board_ids=$(echo "$all_boards" | jq -r '.data[].id // empty' 2>/dev/null)

        for board_id in $board_ids; do
            local board_cards
            board_cards=$(fizzy card list --board "$board_id" --all $fizzy_opts 2>/dev/null) || true
            local board_max
            board_max=$(echo "$board_cards" | jq '[.data[].number // 0] | max // 0' 2>/dev/null) || board_max=0
            if [[ "$board_max" -gt "$current_max_card" ]]; then
                current_max_card="$board_max"
            fi
        done
        log_verbose "Current max card number in account: $current_max_card"

        if [[ -n "$existing_numbers" ]]; then
            log_verbose "Existing card numbers in target board: $existing_numbers"

            # Get existing card numbers as JSON array for efficient filtering
            local existing_numbers_json
            existing_numbers_json=$(echo "$existing_cards" | jq '[.data[].number]')

            # Filter out issues in one jq call
            local total_before=$TOTAL_ISSUES
            issues_json=$(echo "$issues_json" | jq --argjson existing "$existing_numbers_json" \
                '[.[] | select(.number as $n | $existing | index($n) | not)]')
            TOTAL_ISSUES=$(echo "$issues_json" | jq 'length')

            local skipped=$((total_before - TOTAL_ISSUES))
            if [[ $skipped -gt 0 ]]; then
                log_info "Skipped $skipped already-migrated issue(s), $TOTAL_ISSUES remaining"
            fi
        fi

        # Apply limit after filtering
        if [[ "$TOTAL_ISSUES" -gt "$LIMIT" ]]; then
            log_info "Limiting to $LIMIT issue(s) as requested"
            issues_json=$(echo "$issues_json" | jq ".[:$LIMIT]")
            TOTAL_ISSUES="$LIMIT"
        fi
    fi

    if [[ "$TOTAL_ISSUES" == "0" ]]; then
        log_info "No issues to migrate (all already migrated or none found)"
        exit 0
    fi

    log_info "Will migrate $TOTAL_ISSUES issue(s)"

    # Process each issue
    local i=0
    while [[ $i -lt $TOTAL_ISSUES ]]; do
        local issue
        issue=$(echo "$issues_json" | jq ".[$i]")

        local number title body labels_json comments_json created_at issue_state
        number=$(echo "$issue" | jq -r '.number')
        title=$(echo "$issue" | jq -r '.title')
        body=$(echo "$issue" | jq -r '.body // ""')
        labels_json=$(echo "$issue" | jq '.labels // []')
        comments_json=$(echo "$issue" | jq '.comments // []')
        created_at=$(echo "$issue" | jq -r '.createdAt // ""')
        issue_state=$(echo "$issue" | jq -r '.state // "open"')

        log_info "Processing issue #$number ($((i+1))/$TOTAL_ISSUES) [${issue_state}]"

        # Pass expected number if preserve-numbers mode is enabled
        local expected_number=""
        if [[ "$PRESERVE_NUMBERS" == "true" ]]; then
            expected_number="$number"

            # Fill gaps with placeholder cards if needed
            if [[ "$number" -gt $((current_max_card + 1)) ]]; then
                local gaps_filled
                gaps_filled=$(fill_number_gaps "$current_max_card" "$number")
                if [[ $? -ne 0 ]]; then
                    log_error "Failed to fill number gaps before issue #$number"
                    FAIL_COUNT=$((FAIL_COUNT + 1))
                    print_summary
                    exit 6
                fi
                current_max_card=$((number - 1))
            fi
        fi

        local result=0
        create_fizzy_card "$title" "$body" "$labels_json" "$comments_json" "$number" "$created_at" "$expected_number" "$issue_state" || result=$?

        if [[ $result -eq 0 ]]; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            post_migration_github "$number"
            # Update current max card number
            [[ "$PRESERVE_NUMBERS" == "true" ]] && current_max_card="$number"
        elif [[ $result -eq 2 ]]; then
            # Number mismatch - abort immediately
            log_error "Aborting migration due to card number mismatch"
            FAIL_COUNT=$((FAIL_COUNT + 1))
            print_summary
            exit 6
        else
            FAIL_COUNT=$((FAIL_COUNT + 1))
        fi

        i=$((i + 1))
    done

    print_summary

    # Exit with partial failure code if any failed
    if [[ $FAIL_COUNT -gt 0 ]]; then
        exit 5
    fi
}

# Run main with all arguments
main "$@"
